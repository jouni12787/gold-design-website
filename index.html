<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gold Design — Bracelet Builder (Pins + 3D)</title>
<style>
  :root{--radius:14px;--shadow:0 18px 36px rgba(0,0,0,.45)}

  html[data-theme="dark"]{
    --bg:#17120a;
    --bg2:#0f0b06;
    --card:#211a0e;
    --card-overlay:rgba(48,37,19,.86);
    --ink:#fff7e6;
    --muted:#e8d9b3;
    --gold:#d4af37;
    --gold2:#b88a1a;
    --border-soft:rgba(212,175,55,.18);
    --border-strong:rgba(212,175,55,.35);
    --control-border:rgba(212,175,55,.22);
    --control-bg:rgba(23,18,10,.75);
    --control-focus-bg:rgba(33,26,14,.85);
    --control-focus-shadow:rgba(212,175,55,.18);
    --head-bg:rgba(15,11,6,.45);
    --summary-bg:rgba(23,18,10,.85);
    --preview-glow:rgba(212,175,55,.12);
    --tab-bg:rgba(23,18,10,.75);
    --tab-active-bg:rgba(33,26,14,.85);
    --hud-bg:rgba(21,15,8,.72);
    --hud-border:rgba(212,175,55,.2);
    --hud-text:#fff7e6;
    --button-top:rgba(212,175,55,.16);
    --button-bottom:rgba(184,138,26,.16);
    --button-hover-top:rgba(212,175,55,.28);
    --button-hover-bottom:rgba(184,138,26,.2);
    --accent-radial-1:rgba(212,175,55,.16);
    --accent-radial-2:rgba(184,138,26,.22);
    --pin-fill:#d4af37;
    --pin-stroke:#fff7e6;
  }

  html:not([data-theme]),
  html[data-theme="light"]{
    --bg:#f6f2ea;
    --bg2:#e4e9f3;
    --card:#ffffff;
    --card-overlay:rgba(255,255,255,.9);
    --ink:#2b261c;
    --muted:#706b60;
    --gold:#c8892c;
    --gold2:#a56a18;
    --border-soft:rgba(200,137,44,.28);
    --border-strong:rgba(200,137,44,.45);
    --control-border:rgba(200,137,44,.34);
    --control-bg:rgba(250,244,234,.92);
    --control-focus-bg:rgba(255,250,243,.97);
    --control-focus-shadow:rgba(200,137,44,.3);
    --head-bg:rgba(242,234,220,.76);
    --summary-bg:rgba(255,250,243,.92);
    --preview-glow:rgba(200,137,44,.2);
    --tab-bg:rgba(250,244,234,.88);
    --tab-active-bg:rgba(255,250,243,.96);
    --hud-bg:rgba(255,250,243,.96);
    --hud-border:rgba(200,137,44,.38);
    --hud-text:#2b261c;
    --button-top:rgba(200,137,44,.22);
    --button-bottom:rgba(165,106,24,.18);
    --button-hover-top:rgba(200,137,44,.32);
    --button-hover-bottom:rgba(165,106,24,.26);
    --accent-radial-1:rgba(200,137,44,.16);
    --accent-radial-2:rgba(165,106,24,.2);
    --pin-fill:#c8892c;
    --pin-stroke:#2b261c;
  }

  html[data-theme="plum"]{
    --bg:#160b19;
    --bg2:#341844;
    --card:#2b1433;
    --card-overlay:rgba(73,35,94,.72);
    --ink:#f8ecff;
    --muted:#d5c0ec;
    --gold:#d794ff;
    --gold2:#b162e4;
    --border-soft:rgba(215,148,255,.32);
    --border-strong:rgba(215,148,255,.48);
    --control-border:rgba(215,148,255,.36);
    --control-bg:rgba(41,20,51,.78);
    --control-focus-bg:rgba(55,28,68,.86);
    --control-focus-shadow:rgba(215,148,255,.26);
    --head-bg:rgba(39,18,50,.65);
    --summary-bg:rgba(41,20,51,.82);
    --preview-glow:rgba(215,148,255,.18);
    --tab-bg:rgba(41,20,51,.78);
    --tab-active-bg:rgba(55,28,68,.88);
    --hud-bg:rgba(45,22,58,.78);
    --hud-border:rgba(215,148,255,.34);
    --hud-text:#f8ecff;
    --button-top:rgba(215,148,255,.2);
    --button-bottom:rgba(177,98,228,.18);
    --button-hover-top:rgba(215,148,255,.3);
    --button-hover-bottom:rgba(177,98,228,.26);
    --accent-radial-1:rgba(215,148,255,.2);
    --accent-radial-2:rgba(177,98,228,.24);
    --pin-fill:#d794ff;
    --pin-stroke:#f8ecff;
  }

  *{box-sizing:border-box}html,body{height:100%}
  body{margin:0;background:
    radial-gradient(1100px 500px at 15% -15%, var(--accent-radial-1) 0%, transparent 60%),
    radial-gradient(900px 600px at 120% 0%, var(--accent-radial-2) 0%, transparent 70%),
    linear-gradient(160deg, var(--bg) 0%, var(--bg2) 100%);
    color:var(--ink);font:15.5px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;transition:color .3s ease, background .3s ease}
  .wrap{max-width:1200px;margin:28px auto;padding:0 16px;display:grid;gap:18px;grid-template-columns:1fr 1.35fr}
  @media (max-width:980px){.wrap{grid-template-columns:1fr}}
  .card{background:linear-gradient(160deg,var(--card-overlay),var(--card));
    border:1px solid var(--border-soft);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;transition:background .3s ease,border-color .3s ease,box-shadow .3s ease}
  .head{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:16px 18px;border-bottom:1px solid var(--border-soft);background:var(--head-bg)}
  .head h1{margin:0;font-size:18px}
  .headPrimary{display:flex;flex-direction:column;gap:4px}
  .badge{font-size:12px;color:var(--muted)}
  .themePicker{display:inline-flex;align-items:center;gap:8px;font-size:12px;color:var(--muted)}
  .themePicker span{white-space:nowrap}
  .panel{padding:16px 18px}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  select,input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--control-border);background:var(--control-bg);color:var(--ink);outline:none;transition:border .2s,box-shadow .2s,background .2s,color .3s ease}
  select:focus,input:focus{border-color:var(--gold);box-shadow:0 0 0 2px var(--control-focus-shadow);background:var(--control-focus-bg)}
  .themePicker select{width:auto;min-width:120px;padding:6px 10px;font-size:12px}
  .grid2{display:grid;gap:12px;grid-template-columns:1fr 1fr}
  .rows{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .row{display:grid;grid-template-columns:1.2fr .7fr auto auto;gap:10px;align-items:end}
  button{appearance:none;background:linear-gradient(180deg,var(--button-top),var(--button-bottom));color:var(--ink);border:1px solid var(--border-strong);padding:10px 14px;border-radius:12px;cursor:pointer;transition:border .2s,background .2s,color .2s}
  button:hover{border-color:var(--gold);background:linear-gradient(180deg,var(--button-hover-top),var(--button-hover-bottom));color:var(--ink)}
  .summary{margin-top:12px;padding:12px 14px;border-radius:12px;background:var(--summary-bg);border:1px solid var(--border-soft);display:flex;justify-content:space-between;align-items:center;gap:10px}
  .summary .w{color:var(--gold)}
  .buttons{display:flex;gap:10px;flex-wrap:wrap;margin-top:14px}
  .preview{display:flex;align-items:center;justify-content:center;background:
    radial-gradient(600px 400px at 50% 0%, var(--preview-glow) 0%, transparent 70%),
    var(--bg2);min-height:420px;position:relative;transition:background .3s ease}
  svg#stage{width:100%;height:100%;max-height:560px}
  #stage [data-role="background"]{fill:var(--bg2);transition:fill .3s ease}
  .tabs{display:flex;gap:6px}
  .tab{background:var(--tab-bg);border:1px solid var(--border-soft);color:var(--muted);padding:6px 10px;border-radius:10px;cursor:pointer;font-size:12px;transition:border .2s,color .2s,background .2s}
  .tab:hover{color:var(--ink);border-color:var(--gold)}
  .tab.active{border-color:var(--gold);color:var(--gold);background:var(--tab-active-bg)}
  #preview3d{display:none}
  #stlCanvas{width:100%;height:100%;max-height:560px;display:block}
  .stlHud{position:absolute;left:12px;bottom:12px;display:flex;gap:8px;align-items:center;background:var(--hud-bg);border:1px solid var(--hud-border);padding:8px 10px;border-radius:10px;color:var(--hud-text);backdrop-filter:blur(8px);transition:background .3s ease,border-color .3s ease,color .3s ease}
  .stlHud select,.stlHud label{margin:0}
  .stlStatus{position:absolute;right:12px;bottom:12px;font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;background:var(--hud-bg);border:1px solid var(--hud-border);color:var(--hud-text);padding:6px 8px;border-radius:8px;pointer-events:none;transition:background .3s ease,border-color .3s ease,color .3s ease}
  .pin-dot{pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <!-- LEFT -->
  <section class="card">
    <div class="head">
      <div class="headPrimary">
        <h1>Bracelet Builder</h1>
        <span class="badge">Pin snapping · horizontal SVGs</span>
      </div>
      <div class="themePicker">
        <span>Theme</span>
        <select id="themeSelect" aria-label="Select theme">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="plum">Plum</option>
        </select>
      </div>
    </div>
    <div class="panel">
      <div class="grid2">
        <div>
          <label for="pendant">Pendant</label>
          <select id="pendant"></select>
        </div>
        <div>
          <label for="pendantScale">Pendant size (px height)</label>
          <input id="pendantScale" type="number" min="20" max="200" step="2" value="160"/>
        </div>
      </div>

      <div class="rows" id="rows"></div>
      <div style="margin-top:8px"><button id="addRow">+ Add link type</button></div>

      <div class="summary" role="status" aria-live="polite">
        <div><strong>Estimated Weight:</strong> <span class="w" id="weight">0.00 g</span></div>
        <div class="badge">Placeholder grams.</div>
      </div>

      <div class="buttons">
        <button id="downloadSVG">Download SVG</button>
        <button id="downloadPNG">Download PNG</button>
        <button id="reset">Reset</button>
      </div>

      <label style="display:inline-flex;gap:.5rem;align-items:center;margin-top:10px">
        <input type="checkbox" id="showPins"> Show pin overlay
      </label>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <div class="head">
      <h1>Preview</h1>
      <div class="tabs">
        <button class="tab active" id="tab2d">2D</button>
        <button class="tab" id="tab3d">3D (STL)</button>
      </div>
    </div>

    <!-- 2D -->
    <div class="preview" id="preview2d">
      <svg id="stage" viewBox="0 0 1080 400" role="img" aria-label="Bracelet preview">
        <defs id="defs">
          <linearGradient id="gold" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0%" stop-color="#fff7e6"/><stop offset="30%" stop-color="#f1d9a0"/>
            <stop offset="60%" stop-color="#d4af37"/><stop offset="85%" stop-color="#b88a1a"/>
            <stop offset="100%" stop-color="#f6e4bb"/>
          </linearGradient>
          <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#000" flood-opacity=".35"/>
          </filter>
        </defs>
        <rect x="0" y="0" width="1080" height="400" fill="#0f0b06" data-role="background"/>
        <g id="bracelet"></g>
      </svg>
    </div>

    <!-- 3D -->
    <div class="preview" id="preview3d">
      <canvas id="stlCanvas"></canvas>
      <div class="stlHud">
        <select id="stlSelect" title="Choose model">
          <option value="__assembly__">Bracelet assembly</option>
          <option value="pendant/Infinity Knot 1 1mm.stl">Infinity Knot 1 — 1mm</option>
          <option value="link/halo link 1mm.stl">halo link — 1mm</option>
        </select>
        <label style="display:inline-flex;gap:.35rem;align-items:center;">
          <input type="checkbox" id="stlAutoRotate"> Auto rotate
        </label>
        <button id="stlDownload" type="button">Download STL</button>
      </div>
    </div>
  </section>
</div>

<!-- ==================== 2D BUILDER ==================== -->
<script>
"use strict";

const PRICE_ERROR_TEXT_PRIMARY = "تعذّر تحميل سجل الأسعار";
const PRICE_ERROR_TEXT_SECONDARY = "سيتم تحديثه عند وصول قراءات جديدة";
const PRICE_ERROR_EN_PRIMARY = [
  "failed to load the latest price log",
  "failed to load last price log",
  "failed to load the price log"
];
const PRICE_ERROR_EN_SECONDARY = [
  "it will refresh when new readings arrive",
  "it will update when new readings arrive",
  "we'll update it when new readings arrive"
];

function normalizeText(text){
  return (text || "").replace(/\s+/g, " ").trim();
}

function shouldHidePriceError(text){
  if(!text) return false;
  const normalized = normalizeText(text);
  if(normalized.includes(PRICE_ERROR_TEXT_PRIMARY) && normalized.includes(PRICE_ERROR_TEXT_SECONDARY)){
    return true;
  }
  const lower = normalized.toLowerCase();
  const englishPrimary = PRICE_ERROR_EN_PRIMARY.some(snippet => lower.includes(snippet));
  const englishSecondary = PRICE_ERROR_EN_SECONDARY.some(snippet => lower.includes(snippet));
  return englishPrimary && englishSecondary;
}

function hidePriceLogError(root){
  if(!root) return;

  const queue = [];
  if(root.nodeType === Node.ELEMENT_NODE){
    queue.push(root);
  }else if(root.nodeType === Node.DOCUMENT_NODE){
    if(root.body) queue.push(root.body);
  }else if(root.nodeType === Node.DOCUMENT_FRAGMENT_NODE){
    queue.push(...Array.from(root.childNodes).filter(node => node.nodeType === Node.ELEMENT_NODE));
  }

  queue.forEach(node => {
    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, null);
    let current = walker.currentNode;
    while(current){
      if(shouldHidePriceError(current.textContent)){
        current.style.setProperty("display", "none", "important");
      }
      current = walker.nextNode();
    }
  });
}

document.addEventListener("DOMContentLoaded", () => {
  hidePriceLogError(document.body);
  const observer = new MutationObserver(records => {
    for(const record of records){
      if(record.type === "childList"){
        record.addedNodes.forEach(node => {
          if(node.nodeType === Node.ELEMENT_NODE){
            hidePriceLogError(node);
          }else if(node.parentElement){
            hidePriceLogError(node.parentElement);
          }
        });
      }else if(record.type === "characterData" && record.target?.parentElement){
        hidePriceLogError(record.target.parentElement);
      }
    }
  });
  observer.observe(document.body, {childList:true, subtree:true, characterData:true});
});

const THEMES = ["light", "dark", "plum"];
const THEME_KEY = "bracelet-builder-theme";
const DEFAULT_THEME = "light";

function applyTheme(theme){
  const normalized = theme === "navy" ? "dark" : theme;
  const next = THEMES.includes(normalized) ? normalized : DEFAULT_THEME;
  document.documentElement.dataset.theme = next;
  if(typeof window.__update3DTheme === "function"){
    window.__update3DTheme(next);
  }
  try{
    if(typeof localStorage !== "undefined") localStorage.setItem(THEME_KEY, next);
  }catch(_){/* ignore */}
  return next;
}

let currentTheme = DEFAULT_THEME;
try{
  const stored = (typeof localStorage !== "undefined") ? localStorage.getItem(THEME_KEY) : null;
  if(stored) currentTheme = stored;
}catch(_){ currentTheme = DEFAULT_THEME; }
currentTheme = applyTheme(currentTheme);

/* Exact asset names */
const PENDANTS = ["Infinity Knot 1.svg"];
const LINKS    = ["halo link.svg"];

/* Link layout meta (tweak targetH if your halo looks too big/small) */
const LINK_META = { "halo link.svg": { targetH: 34, rotate: 0 } };

const STL_FILES = {
  pendant: {
    "Infinity Knot 1.svg": "pendant/Infinity Knot 1 1mm.stl"
  },
  link: {
    "halo link.svg": "link/halo link 1mm.stl"
  }
};

/* Placeholder weights */
const WEIGHTS = {
  "Infinity Knot 1.svg": 0.32,
  "halo link.svg": 0.10,
  "__default_pendant": 0.30,
  "__default_link": 0.10
};

/* DOM refs */
const stage = document.getElementById("stage");
const defs = document.getElementById("defs");
const bracelet = document.getElementById("bracelet");
const selTheme = document.getElementById("themeSelect");
const selPendant = document.getElementById("pendant");
const inpPendantScale = document.getElementById("pendantScale");
const rowsBox = document.getElementById("rows");
const btnAddRow = document.getElementById("addRow");
const lblWeight = document.getElementById("weight");
const btnSVG = document.getElementById("downloadSVG");
const btnPNG = document.getElementById("downloadPNG");
const btnReset = document.getElementById("reset");
const chkPins = document.getElementById("showPins");

let lastToken = 0;

/* Utils */
const enc = s => encodeURIComponent(s); // keep %20 for spaces (GitHub Pages)
async function fetchSVGText(path){ const r=await fetch(path); if(!r.ok) throw new Error("load "+path); return r.text(); }
function parseSVG(text){ return new DOMParser().parseFromString(text,"image/svg+xml").documentElement; }
function clear(n){ while(n.firstChild) n.removeChild(n.firstChild); }
function makeOption(t,v){ const o=document.createElement("option"); o.textContent=t; o.value=v; return o; }
function weightFor(name,type){ return WEIGHTS[name] ?? (type==="pendant" ? WEIGHTS.__default_pendant : WEIGHTS.__default_link); }
const toNum = v => (v==null||v==="") ? null : (typeof v==="number" ? v : parseFloat(String(v)));
function parseCoord(v, dim){ if(v==null) return null; const s=String(v).trim(); return s.endsWith("%") ? parseFloat(s)/100*dim : parseFloat(s); }
function drawDot(parent,x,y,r=3,colors){
  const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx",x);
  c.setAttribute("cy",y);
  c.setAttribute("r",r);
  c.setAttribute("fill",colors?.fill || "#d4af37");
  c.setAttribute("stroke",colors?.stroke || "#fff7e6");
  c.setAttribute("stroke-width","1");
  c.setAttribute("class","pin-dot");
  parent.appendChild(c);
}

/* Load SVG, scale, rotate, extract invisible pins */
async function loadScaleRotate(dir, filename, targetH, rotateDeg){
  const url = `./${dir}/${enc(filename)}`;
  const svg = parseSVG(await fetchSVGText(url));

  let vb = svg.getAttribute("viewBox");
  let w,h;
  if(vb){ const parts = vb.replace(/,/g," ").trim().split(/\s+/).map(Number); w=parts[2]; h=parts[3]; }
  else{ w = toNum(svg.getAttribute("width")) || 100; h = toNum(svg.getAttribute("height")) || 100; }

  const scale = targetH / h;
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");

  [...svg.childNodes].forEach(n=>{
    if(n.nodeType===1){
      if(n.tagName.toLowerCase()==="defs"){
        [...n.children].forEach(el=>{
          const id = el.id ? `${filename.replace(/\W+/g,'_')}_${el.id}` : "";
          if(id) el.setAttribute("id", id);
          defs.appendChild(stage.ownerDocument.importNode(el,true));
        });
      }else{
        g.appendChild(stage.ownerDocument.importNode(n,true));
      }
    }
  });

  const cxS=(w*scale)/2, cyS=(h*scale)/2;
  let tf = `scale(${scale})`;
  if(rotateDeg && Math.abs(rotateDeg)%360!==0){ tf += ` rotate(${rotateDeg}, ${w/2}, ${h/2})`; }
  g.setAttribute("transform", tf);

  let outW = (Math.abs((rotateDeg||0)%180)===90) ? h*scale : w*scale;
  let outH = (Math.abs((rotateDeg||0)%180)===90) ? w*scale : h*scale;

  let pinL=null, pinR=null;
  const pinsGroup = svg.querySelector("#pins");
  if(pinsGroup){
    const cL = pinsGroup.querySelector("#pinL");
    const cR = pinsGroup.querySelector("#pinR");
    if(cL && cR){
      let pxL = parseCoord(cL.getAttribute("cx"), w) * scale;
      let pyL = parseCoord(cL.getAttribute("cy"), h) * scale;
      let pxR = parseCoord(cR.getAttribute("cx"), w) * scale;
      let pyR = parseCoord(cR.getAttribute("cy"), h) * scale;

      const rot = (rotateDeg||0) * Math.PI/180;
      if(rot!==0){
        function rotP(x,y){ const dx=x-cxS, dy=y-cyS; return {x: cxS + (dx*Math.cos(rot)-dy*Math.sin(rot)), y: cyS + (dx*Math.sin(rot)+dy*Math.cos(rot))}; }
        const a = rotP(pxL,pyL), b = rotP(pxR,pyR);
        pinL=a; pinR=b;
      }else{ pinL={x:pxL,y:pyL}; pinR={x:pxR,y:pyR}; }
    }
  }

  const pinRatios = {
    L: pinL && outW && outH ? { x: pinL.x/outW, y: pinL.y/outH } : null,
    R: pinR && outW && outH ? { x: pinR.x/outW, y: pinR.y/outH } : null
  };

  return {
    node:g,
    width:outW,
    height:outH,
    rawWidth:w,
    rawHeight:h,
    scale:scale,
    rotation: rotateDeg || 0,
    pins:{L:pinL,R:pinR},
    pinRatios
  };
}

/* Init UI */
(function init(){
  PENDANTS.forEach(n=> selPendant.appendChild(makeOption(n,n)));
  selPendant.value = PENDANTS[0];

  addRow({type:LINKS[0], qty:6}); // one link row by default

  if(selTheme){
    selTheme.value = THEMES.includes(selTheme.value) ? selTheme.value : currentTheme;
    if(selTheme.value !== currentTheme) selTheme.value = currentTheme;
    selTheme.addEventListener("change", e=>{
      const chosen = applyTheme(e.target.value);
      currentTheme = chosen;
      render();
    });
  }

  btnAddRow.addEventListener("click", ()=>addRow());
  selPendant.addEventListener("change", render);
  inpPendantScale.addEventListener("input", render);
  btnSVG.addEventListener("click", downloadSVG);
  btnPNG.addEventListener("click", downloadPNG);
  btnReset.addEventListener("click", ()=>{
    rowsBox.innerHTML="";
    addRow({type:LINKS[0], qty:6});
    selPendant.value=PENDANTS[0];
    inpPendantScale.value=160;
    render();
  });
  document.getElementById('tab2d').addEventListener('click', ()=>switchMode('2d'));
  document.getElementById('tab3d').addEventListener('click', ()=>switchMode('3d'));
  render();
})();

function addRow(init={type:LINKS[0], qty:6}){
  const row = document.createElement("div"); row.className="row";
  const sel = document.createElement("select"); LINKS.forEach(n=> sel.appendChild(makeOption(n,n))); sel.value = init.type;
  const qty = document.createElement("input"); qty.type="number"; qty.min="0"; qty.max="80"; qty.step="1"; qty.value = String(init.qty ?? 6);
  const addBtn=document.createElement("button"); addBtn.textContent="+ Duplicate";
  const delBtn=document.createElement("button"); delBtn.textContent="– Remove";

  row.appendChild(sel); row.appendChild(qty); row.appendChild(addBtn); row.appendChild(delBtn);
  rowsBox.appendChild(row);
  sel.addEventListener("change", render);
  qty.addEventListener("input", render);
  addBtn.addEventListener("click", ()=>{ addRow({type:sel.value, qty:qty.valueAsNumber||0}); render(); });
  delBtn.addEventListener("click", ()=>{ rowsBox.removeChild(row); render(); });
}

function readRows(){
  return [...rowsBox.querySelectorAll(".row")].map(r=>{
    const type = r.querySelector("select").value;
    const qty = r.querySelector('input[type="number"]').valueAsNumber||0;
    return {type, qty};
  }).filter(r=>r.qty>0);
}

/* Gold tint */
function tintGold(node){
  const w = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT);
  while(w.nextNode()){
    const el=w.currentNode, tag=el.tagName?.toLowerCase?.()||"";
    if(["path","circle","ellipse","rect","polygon","polyline","line"].includes(tag)){
      const fill = el.getAttribute("fill");
      const stroke = el.getAttribute("stroke");
      if(!fill || fill!=="none") el.setAttribute("fill","url(#gold)");
      if(stroke && stroke!=="none") el.setAttribute("stroke","#b88a1a");
      el.setAttribute("filter","url(#softShadow)");
    }
  }
}

function clonePoint(pt){ return pt ? {x: pt.x, y: pt.y} : null; }

function sanitizePackFor3D(pack, type, name){
  if(!pack) return null;
  const stl = (type === 'pendant' ? STL_FILES.pendant[name] : STL_FILES.link[name]) || null;
  const pinRatios = pack.pinRatios || {};
  return {
    type,
    name,
    stl,
    width: pack.width,
    height: pack.height,
    rawWidth: pack.rawWidth,
    rawHeight: pack.rawHeight,
    scale: pack.scale,
    rotation: pack.rotation || 0,
    pins: {
      L: clonePoint(pack.pins?.L),
      R: clonePoint(pack.pins?.R)
    },
    pinRatios: {
      L: pinRatios.L ? {x: pinRatios.L.x, y: pinRatios.L.y} : null,
      R: pinRatios.R ? {x: pinRatios.R.x, y: pinRatios.R.y} : null
    }
  };
}

/* Render everything */
async function render(){
  const token=++lastToken;
  clear(bracelet);

  const themeStyles = getComputedStyle(document.documentElement);
  const bg2 = (themeStyles.getPropertyValue("--bg2") || "").trim() || "#0f0b06";
  const stageBg = stage.querySelector('[data-role="background"]');
  if(stageBg) stageBg.setAttribute("fill", bg2);
  const pinColors = {
    fill: (themeStyles.getPropertyValue("--pin-fill") || "").trim() || "#d4af37",
    stroke: (themeStyles.getPropertyValue("--pin-stroke") || "").trim() || "#fff7e6"
  };

  const rows = readRows();
  const pendantName = selPendant.value;
  const pendantH = Math.max(20, Math.min(200, inpPendantScale.valueAsNumber||160));

  const dbg = document.createElementNS("http://www.w3.org/2000/svg","g");
  dbg.setAttribute("id","pinOverlay");
  bracelet.appendChild(dbg);

  const layoutLeft=[];
  const layoutRight=[];
  let layoutPendant=null;

  // Pendant
  let pendantPack;
  try{
    pendantPack = await loadScaleRotate("pendant", pendantName, pendantH, 0);
  }catch(e){ console.error(e); pendantPack = {node:document.createElementNS("http://www.w3.org/2000/svg","g"), width:120, height:60, pins:{L:null,R:null}}; }
  if(token!==lastToken) return;
  const pendant3D = sanitizePackFor3D(pendantPack, 'pendant', pendantName);

  // Link defs
  const uniq = [...new Set(rows.map(r=>r.type))];
  const linkDefs = {};
  for(const t of uniq){
    const meta = LINK_META[t] || {targetH:34, rotate:0};
    try{
      linkDefs[t] = await loadScaleRotate("link", t, meta.targetH, meta.rotate);
    }catch(e){ console.error(e); }
    if(token!==lastToken) return;
  }

  // Layout
  const PAD=40, W=1080, midY=200;
  function spanOf(def){ if(def?.pins?.L && def?.pins?.R) return def.pins.R.x - def.pins.L.x; return def?.width ?? 0; }

  const leftSeq=[]; rows.forEach(r=>{ for(let i=0;i<r.qty;i++) leftSeq.push(r.type); });
  const rightSeq=[...leftSeq].reverse();

  const leftSpan = leftSeq.reduce((s,t)=> s + spanOf(linkDefs[t]), 0);
  const rightSpan= rightSeq.reduce((s,t)=> s + spanOf(linkDefs[t]), 0);
  const pendSpan = spanOf(pendantPack);

  const totalSpan = leftSpan + pendSpan + rightSpan;
  let startX = Math.max(PAD, (W - totalSpan)/2);

  // Pendant position
  const pendPinMidY = (pendantPack.pins?.L?.y != null && pendantPack.pins?.R?.y != null)
                      ? (pendantPack.pins.L.y + pendantPack.pins.R.y)/2
                      : pendantPack.height/2;
  const pendantLeftPinWorldX = startX + leftSpan;
  const gpX = pendantLeftPinWorldX - (pendantPack.pins?.L?.x ?? 0);
  const gpY = midY - pendPinMidY;

  const gp = document.createElementNS("http://www.w3.org/2000/svg","g");
  gp.setAttribute("transform", `translate(${gpX}, ${gpY})`);
  tintGold(pendantPack.node); gp.appendChild(pendantPack.node); bracelet.appendChild(gp);

  layoutPendant = {
    type:'pendant',
    pack: pendant3D,
    tx: gpX,
    ty: gpY,
    pins: {
      L: pendantPack.pins?.L ? {x: gpX + pendantPack.pins.L.x, y: gpY + pendantPack.pins.L.y} : null,
      R: pendantPack.pins?.R ? {x: gpX + pendantPack.pins.R.x, y: gpY + pendantPack.pins.R.y} : null
    }
  };

  if (chkPins?.checked && pendantPack.pins?.L && pendantPack.pins?.R) {
    drawDot(dbg, gpX + pendantPack.pins.L.x, gpY + pendantPack.pins.L.y, 3, pinColors);
    drawDot(dbg, gpX + pendantPack.pins.R.x, gpY + pendantPack.pins.R.y, 3, pinColors);
  }

  // Left side
  let anchorL = {x: pendantLeftPinWorldX, y: midY};
  for(let i=leftSeq.length-1;i>=0;i--){
    const t = leftSeq[i];
    const d = linkDefs[t]; if(!d) continue;
    const L = d.pins?.L, R = d.pins?.R;

    const tx = (L && R) ? (anchorL.x - R.x) : (anchorL.x - d.width);
    const ty = (L && R) ? (anchorL.y - R.y) : (midY - d.height/2);

    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("transform", `translate(${tx}, ${ty})`);
    const node = d.node.cloneNode(true); tintGold(node);
    g.appendChild(node); bracelet.appendChild(g);

    layoutLeft.unshift({
      type:'link',
      name:t,
      pack: sanitizePackFor3D(d, 'link', t),
      tx,
      ty,
      pins: {
        L: L ? {x: tx + L.x, y: ty + L.y} : null,
        R: R ? {x: tx + R.x, y: ty + R.y} : null
      }
    });

    if(chkPins?.checked && L && R){ drawDot(dbg, tx+L.x, ty+L.y, 3, pinColors); drawDot(dbg, tx+R.x, ty+R.y, 3, pinColors); }
    anchorL = L && R ? {x: tx + L.x, y: ty + L.y} : {x: tx, y: midY};
  }

  // Right side
  let anchorR = {x: pendantLeftPinWorldX + pendSpan, y: midY};
  for(let i=0;i<rightSeq.length;i++){
    const t = rightSeq[i];
    const d = linkDefs[t]; if(!d) continue;
    const L = d.pins?.L, R = d.pins?.R;

    const tx = (L && R) ? (anchorR.x - L.x) : (anchorR.x);
    const ty = (L && R) ? (anchorR.y - L.y) : (midY - d.height/2);

    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("transform", `translate(${tx}, ${ty})`);
    const node = d.node.cloneNode(true); tintGold(node);
    g.appendChild(node); bracelet.appendChild(g);

    layoutRight.push({
      type:'link',
      name:t,
      pack: sanitizePackFor3D(d, 'link', t),
      tx,
      ty,
      pins: {
        L: L ? {x: tx + L.x, y: ty + L.y} : null,
        R: R ? {x: tx + R.x, y: ty + R.y} : null
      }
    });

    if(chkPins?.checked && L && R){ drawDot(dbg, tx+L.x, ty+L.y, 3, pinColors); drawDot(dbg, tx+R.x, ty+R.y, 3, pinColors); }
    anchorR = L && R ? {x: tx + R.x, y: ty + R.y} : {x: tx + d.width, y: midY};
  }

  // Weight
  const pendantW = weightFor(pendantName,"pendant");
  const linksW = rows.reduce((s,r)=> s + weightFor(r.type,"link") * r.qty*2, 0);
  lblWeight.textContent = (pendantW + linksW).toFixed(2) + " g";

  const layoutPayload = {
    items: [...layoutLeft, ...(layoutPendant ? [layoutPendant] : []), ...layoutRight],
    stage: { width: W, height: 400 },
    timestamp: Date.now()
  };
  window.__bracelet3DLayout = layoutPayload;
  if(typeof window.__update3DAssembly === 'function'){
    try{ window.__update3DAssembly(layoutPayload); }
    catch(err){ console.error('3D update failed', err); }
  }
}

/* Export */
function downloadSVG(){
  const clone = stage.cloneNode(true);
  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml],{type:"image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(blob); trigger(url,"bracelet.svg");
}
function downloadPNG(){
  const clone = stage.cloneNode(true); clone.setAttribute("width","1080"); clone.setAttribute("height","400");
  const xml = new XMLSerializer().serializeToString(clone);
  const data = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(xml)));
  const img = new Image();
  img.onload = function(){
    const canvas=document.createElement("canvas"); canvas.width=1080; canvas.height=400;
    const ctx=canvas.getContext("2d"); ctx.drawImage(img,0,0,1080,400);
    canvas.toBlob(b=> trigger(URL.createObjectURL(b),"bracelet.png"),"image/png",0.98);
  };
  img.src = data;
}
function trigger(url,name){ const a=document.createElement("a"); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),4000); }

/* Tab switcher with hard 3D resize */
function switchMode(which){
  const b2d=document.getElementById('tab2d'), b3d=document.getElementById('tab3d');
  const p2d=document.getElementById('preview2d'), p3d=document.getElementById('preview3d');
  if(which==='3d'){
    b3d.classList.add('active'); b2d.classList.remove('active');
    p3d.style.display='flex'; p2d.style.display='none';
    setTimeout(()=>{ window.dispatchEvent(new Event('resize')); if(window.__resize3D) window.__resize3D(); }, 50);
  }else{
    b2d.classList.add('active'); b3d.classList.remove('active');
    p2d.style.display='flex'; p3d.style.display='none';
  }
}
</script>

<!-- ==================== 3D VIEWER (fixed) ==================== -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { STLExporter } from 'three/addons/exporters/STLExporter.js';

const container = document.getElementById('preview3d');
const canvas    = document.getElementById('stlCanvas');
const sel       = document.getElementById('stlSelect');
const auto      = document.getElementById('stlAutoRotate');
const btnDownload = document.getElementById('stlDownload');

// Debug HUD (load status + size)
const msg = document.createElement('div');
msg.className = 'stlStatus';
container.appendChild(msg);

const loader = new STLLoader();
const exporter = new STLExporter();
const geometryCache = new Map();
const metricsCache = new WeakMap();

let renderer, scene, camera, controls;
let currentObject = null;
let activeMaterials = [];
let wire = false;
let loadToken = 0;
let lastLayout = null;
let stageHeight = 400;

window.__update3DAssembly = handleLayoutUpdate;
if(window.__bracelet3DLayout){
  handleLayoutUpdate(window.__bracelet3DLayout);
}

init();
loadCurrent();

sel.addEventListener('change', loadCurrent);
auto.addEventListener('change', ()=> controls.autoRotate = auto.checked);
btnDownload.addEventListener('click', downloadCurrent);
window.addEventListener('resize', resize3D);
// let non-module switcher force-resize when tab opens
window.__resize3D = resize3D;

function updateViewerTheme(){
  if(!scene) return;
  const styles = getComputedStyle(document.documentElement);
  const bg = (styles.getPropertyValue('--bg2') || '').trim() || '#0f0b06';
  let bgColor;
  try{ bgColor = new THREE.Color(bg); }
  catch(_){ bgColor = new THREE.Color(0x0f0b06); }
  scene.background = bgColor;
  if(renderer){ renderer.setClearColor(bgColor, 1); }

  const accent = (styles.getPropertyValue('--gold') || '').trim() || '#d4af37';
  activeMaterials.forEach(mat=> mat.color.set(accent));

  if(msg){
    const hudBg = (styles.getPropertyValue('--hud-bg') || '').trim() || 'rgba(21,15,8,.72)';
    const hudBorder = (styles.getPropertyValue('--hud-border') || '').trim() || 'rgba(212,175,55,.2)';
    const hudText = (styles.getPropertyValue('--hud-text') || '').trim() || '#fff7e6';
    msg.style.backgroundColor = hudBg;
    msg.style.borderColor = hudBorder;
    msg.style.color = hudText;
  }
}

window.__update3DTheme = updateViewerTheme;

function init(){
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(40, 1, 0.01, 5000);
  camera.position.set(0, 0, 10);

  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.75;

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.autoRotate = auto.checked;
  controls.autoRotateSpeed = 1.2;

  // lights
  const ambient = new THREE.AmbientLight(0xffffff, 1.35); scene.add(ambient);
  const hemi = new THREE.HemisphereLight(0xfff4d2, 0x201810, 0.75); scene.add(hemi);
  const d1 = new THREE.DirectionalLight(0xffffff, 1.6); d1.position.set(6,7,10); scene.add(d1);
  const d2 = new THREE.DirectionalLight(0xfff4d2, 1.1); d2.position.set(-6,-4,5); scene.add(d2);
  const rim = new THREE.DirectionalLight(0xfff6e0, 0.9); rim.position.set(-3, 5, -4); scene.add(rim);
  const fill = new THREE.DirectionalLight(0xfff0d8, 0.75); fill.position.set(0, 2, -8); scene.add(fill);
  const frontFill = new THREE.PointLight(0xfff4d2, 0.65, 22);
  frontFill.position.set(0, -1, 6);
  scene.add(frontFill);

  // press "W" to toggle wireframe (debug)
  window.addEventListener('keydown', e=>{
    if(e.key.toLowerCase()==='w'){
      wire = !wire;
      activeMaterials.forEach(mat=> mat.wireframe = wire);
    }
  });

  resize3D();
  updateViewerTheme();
  animate();
}

function resize3D(){
  const r = container.getBoundingClientRect();
  const w = Math.max(200, r.width);
  const h = Math.max(300, r.height);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h, false);
}

async function loadCurrent(){
  const token = ++loadToken;
  controls.autoRotate = auto.checked;
  if(sel.value === '__assembly__'){
    await loadAssembly(token);
  }else{
    await loadSingle(sel.value, token);
  }
}

async function loadSingle(raw, token){
  try{
    msg.textContent = 'Loading… ' + raw;
    const geom = await loadGeometry(raw);
    if(token !== loadToken) return;

    clearCurrentObject();
    const mat = createMaterial();
    const mesh = new THREE.Mesh(geom, mat);
    currentObject = mesh;
    scene.add(mesh);
    fitToView(mesh);

    updateViewerTheme();

    const box = new THREE.Box3().setFromObject(mesh);
    const sz  = new THREE.Vector3(); box.getSize(sz);
    msg.textContent = `Loaded ✓  size: ${sz.x.toFixed(2)} × ${sz.y.toFixed(2)} × ${sz.z.toFixed(2)}`;
  }catch(err){
    if(token !== loadToken) return;
    console.error('STL load failed:', err);
    msg.textContent = 'Load failed — see console';
  }
}

async function loadAssembly(token){
  const layout = lastLayout || window.__bracelet3DLayout;
  if(!layout || !Array.isArray(layout.items) || layout.items.length===0){
    clearCurrentObject();
    msg.textContent = 'Assembly not ready — adjust bracelet in 2D.';
    return;
  }

  stageHeight = layout.stage?.height ?? stageHeight;
  const items = layout.items.filter(item=> item?.pack?.stl);
  if(items.length===0){
    clearCurrentObject();
    msg.textContent = 'Assembly has no STL-backed components yet.';
    return;
  }

  msg.textContent = 'Building assembly…';

  try{
    const paths = [...new Set(items.map(item=> item.pack.stl))];
    await Promise.all(paths.map(path=> loadGeometry(path)));
  }catch(err){
    if(token !== loadToken) return;
    console.error('Assembly STL load failed:', err);
    msg.textContent = 'Assembly load failed — see console';
    return;
  }
  if(token !== loadToken) return;

  clearCurrentObject();
  const group = new THREE.Group();
  activeMaterials = [];

  for(const item of items){
    const geom = await loadGeometry(item.pack.stl);
    if(token !== loadToken) return;
    const metrics = getMetrics(geom);
    const scale = computeScale(item.pack, metrics);
    const mat = createMaterial();
    const mesh = new THREE.Mesh(geom, mat);
    mesh.scale.set(scale, scale, scale);
    const pos = computePlacement(item, metrics, scale);
    mesh.position.copy(pos);
    group.add(mesh);
  }

  if(!group.children.length){
    msg.textContent = 'Assembly has no renderable meshes.';
    return;
  }

  const bbox = new THREE.Box3().setFromObject(group);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  group.position.set(-center.x, -center.y, -center.z);

  scene.add(group);
  currentObject = group;
  fitToView(group);
  updateViewerTheme();

  const sz = new THREE.Vector3(); bbox.getSize(sz);
  msg.textContent = `Assembly ✓  size: ${sz.x.toFixed(2)} × ${sz.y.toFixed(2)} × ${sz.z.toFixed(2)}`;
}

function computeScale(pack, metrics){
  const size = metrics.size;
  if(pack?.height && size.y > 1e-6){
    return pack.height / size.y;
  }
  if(pack?.width && size.x > 1e-6){
    return pack.width / size.x;
  }
  return 1;
}

function computePlacement(item, metrics, scale){
  const pack = item.pack || {};
  const pins = item.pins || {};
  const ratioL = pack.pinRatios?.L;
  const ratioR = pack.pinRatios?.R;

  const localL = ratioToLocal(ratioL, metrics).multiplyScalar(scale);
  const localR = ratioToLocal(ratioR, metrics).multiplyScalar(scale);

  const fallback = fallbackPoint(item, pack);
  const targetL = pins.L ? to3DPoint(pins.L) : to3DPoint(fallback);
  const targetR = pins.R ? to3DPoint(pins.R) : (pins.L ? to3DPoint(pins.L) : to3DPoint(fallback));

  let posX = targetL.x - localL.x;
  let posY = targetL.y - localL.y;

  if(pins.R || ratioR){
    const altX = targetR.x - localR.x;
    const altY = targetR.y - localR.y;
    if(Number.isFinite(altX)) posX = (posX + altX)/2;
    if(Number.isFinite(altY)) posY = (posY + altY)/2;
  }

  return new THREE.Vector3(posX, posY, 0);
}

function ratioToLocal(ratio, metrics){
  const { box, size } = metrics;
  const clamp = (v)=> Math.min(Math.max(v ?? 0.5, 0), 1);
  const rx = clamp(ratio?.x);
  const ry = clamp(ratio?.y);
  const rz = clamp(ratio?.z);
  return new THREE.Vector3(
    box.min.x + size.x * rx,
    box.min.y + size.y * ry,
    box.min.z + size.z * rz
  );
}

function fallbackPoint(item, pack){
  const w = pack?.width ?? 0;
  const h = pack?.height ?? 0;
  const tx = item?.tx ?? 0;
  const ty = item?.ty ?? 0;
  return { x: tx + w/2, y: ty + h/2 };
}

function to3DPoint(pt){
  const x = typeof pt?.x === 'number' ? pt.x : 0;
  const y = typeof pt?.y === 'number' ? pt.y : 0;
  return new THREE.Vector3(x, (stageHeight/2) - y, 0);
}

async function loadGeometry(rawPath){
  if(!rawPath) return null;
  if(geometryCache.has(rawPath)) return geometryCache.get(rawPath);
  const url = rawPath.replace(/ /g, '%20');
  const promise = loader.loadAsync(url).then(geom=>{
    geom.computeVertexNormals();
    return geom;
  }).catch(err=>{
    geometryCache.delete(rawPath);
    throw err;
  });
  geometryCache.set(rawPath, promise);
  return promise;
}

function getMetrics(geom){
  if(metricsCache.has(geom)) return metricsCache.get(geom);
  if(!geom.boundingBox) geom.computeBoundingBox();
  const box = geom.boundingBox.clone();
  const size = new THREE.Vector3(); box.getSize(size);
  const metrics = { box, size };
  metricsCache.set(geom, metrics);
  return metrics;
}

function createMaterial(){
  const mat = new THREE.MeshPhysicalMaterial({
    color: 0xd4af37,
    metalness: 1,
    roughness: 0.25,
    reflectivity: 1,
    clearcoat: 0.5,
    clearcoatRoughness: 0.3,
    side: THREE.DoubleSide,
    wireframe: wire
  });
  activeMaterials.push(mat);
  return mat;
}

function clearCurrentObject(){
  if(!currentObject) return;
  if(currentObject.traverse){
    currentObject.traverse(node=>{
      if(node.isMesh && node.material?.dispose){
        node.material.dispose();
      }
    });
  }else if(currentObject.isMesh && currentObject.material?.dispose){
    currentObject.material.dispose();
  }
  scene.remove(currentObject);
  currentObject = null;
  activeMaterials = [];
}

function fitToView(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const center = new THREE.Vector3(); box.getCenter(center);
  obj.position.sub(center);
  controls.target.set(0,0,0);

  const size = new THREE.Vector3(); box.getSize(size);
  let maxDim = Math.max(size.x || 0, size.y || 0, size.z || 0);
  if(!isFinite(maxDim) || maxDim <= 1e-6) maxDim = 50; // fallback for tiny/flat models

  const fov = camera.fov * (Math.PI/180);
  let dist = maxDim / (2 * Math.tan(fov/2));
  dist *= 1.6;
  camera.position.set(dist, dist*0.2, dist);
  camera.lookAt(0,0,0);
  controls.update();
}

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function downloadCurrent(){
  if(!currentObject){
    msg.textContent = 'Nothing to export yet.';
    return;
  }
  try{
    const data = exporter.parse(currentObject, {binary:true});
    const blob = new Blob([data], {type:'model/stl'});
    const name = makeFileName(sel.value);
    triggerDownload(blob, name);
    msg.textContent = 'STL download started.';
  }catch(err){
    console.error('STL export failed:', err);
    msg.textContent = 'Export failed — see console';
  }
}

function triggerDownload(blob, name){
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = name;
  document.body.appendChild(link);
  link.click();
  link.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 4000);
}

function makeFileName(raw){
  if(raw === '__assembly__') return 'bracelet-assembly.stl';
  const base = (raw.split('/').pop() || 'model.stl').trim();
  const safe = base.replace(/\s+/g,'-').toLowerCase();
  return safe.endsWith('.stl') ? safe : `${safe}.stl`;
}

function handleLayoutUpdate(layout){
  lastLayout = layout;
  if(layout?.stage?.height) stageHeight = layout.stage.height;
  if(sel.value === '__assembly__' && controls){
    loadCurrent();
  }
}
</script>
</body>
</html>
